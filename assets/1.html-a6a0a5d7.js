import{_ as s,a as r,b as o,c as d,d as l,e as c}from"./sparse-primary-indexes-3-3819e461.js";import{_ as h}from"./plugin-vue_export-helper-c27b6911.js";import{r as u,o as m,c as p,d as v,a as e,b as i,e as a,f as t}from"./app-42b18c27.js";const g={},f=e("p",null,"In the intricate landscape of information systems, reporting engines stand as indispensable components. They empower users with access to data, facilitating rapid analysis and informed decision-making.",-1),b=e("p",null,"In this post, we delve into the technical intricacies of syncing a MySQL transactional database with ClickHouse, a columnar analytics-oriented engine. This strategic approach lays the foundation for constructing a robust, scalable, and high-performance reporting engine adept at handling substantial data volumes.",-1),_=t('<h2 id="big-data-that-s-it-right" tabindex="-1"><a class="header-anchor" href="#big-data-that-s-it-right" aria-hidden="true">#</a> &quot;Big Data, that&#39;s it! Right?&quot;</h2><p>Embarking on a data engineering project can be overwhelming, especially when taking the first steps into this vast world. The landscape of options seems to become infinite with the advancement of new technologies, architectures, frameworks, and even paradigms.</p><p>Every day, we witness the growing amount of information we store, traffic, and process. It&#39;s not always easy to foresee the exponential growth in the production of new data in a timely manner. This may be due to a natural evolutionary inertia in terms of the lifespan of a software project. You may hear, &quot;We need to access more information, faster,&quot; but... do we?</p><p>Depending on the type of solution the software is offering, both its architecture and infrastructure may have evolved over time. In general (not always), one starts with a relational database, which is usually simple to understand, set up, and manipulate. These databases are perhaps the first point of contact that a programmer typically encounters when delving into the realm of data. It&#39;s worth mentioning that any solution requiring transaction processing usually stores its information in a relational database, such as MySQL, MariaDB, SQL Server, or Oracle.</p><h3 id="column-oriented-vs-row-oriented" tabindex="-1"><a class="header-anchor" href="#column-oriented-vs-row-oriented" aria-hidden="true">#</a> Column-Oriented vs Row-Oriented</h3><ul><li>In a row-oriented database management system (DBMS), data is stored in rows, with all values related to a row stored physically next to each other. <img src="'+s+'" alt="row-oriented.gif" loading="lazy"></li><li>In a column-oriented DBMS, data is stored in columns, with values from the same columns stored together. <img src="'+r+'" alt="column-oriented.gif" loading="lazy"></li></ul><h2 id="clickhouse" tabindex="-1"><a class="header-anchor" href="#clickhouse" aria-hidden="true">#</a> Clickhouse</h2><p>ClickHouse is a high-performance, column-oriented SQL database management system (DBMS) for online analytical processing (OLAP). It is available as both an open-source software and a cloud offering.</p><h3 id="engine-mergetree" tabindex="-1"><a class="header-anchor" href="#engine-mergetree" aria-hidden="true">#</a> ENGINE MergeTree</h3>',9),y=e("li",null,"It can be considered ClickHouse's default engine.",-1),E={href:"https://www2.cs.sfu.ca/CourseCentral/354/zaiane/material/notes/Chapter11/node5.html",target:"_blank",rel:"noopener noreferrer"},w=t(`<li>Data can be partitioned (partitions + parts).</li><li>Creation statement:<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr1] [COMMENT ...] [CODEC(codec1)] [TTL expr1] [PRIMARY KEY],
    name2 [type2] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr2] [COMMENT ...] [CODEC(codec2)] [TTL expr2] [PRIMARY KEY],
    ...
    INDEX index_name1 expr1 TYPE type1(...) [GRANULARITY value1],
    INDEX index_name2 expr2 TYPE type2(...) [GRANULARITY value2],
    ...
    PROJECTION projection_name_1 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY]),
    PROJECTION projection_name_2 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY])
) ENGINE = MergeTree()
ORDER BY expr
[PARTITION BY expr]
[PRIMARY KEY expr]
[SAMPLE BY expr]
[TTL expr
    [DELETE|TO DISK &#39;xxx&#39;|TO VOLUME &#39;xxx&#39; [, ...] ]
    [WHERE conditions]
    [GROUP BY key_expr [SET v1 = aggr_func(v1) [, v2 = aggr_func(v2) ...]] ] ]
[SETTINGS name=value, ...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ENGINE — The MergeTree() engine takes no parameters.</li><li>ORDER BY — The sorting key - ClickHouse uses the sorting key to determine how information is stored on disk. It also serves specific functions in MergeTree family engines, such as aggregation key in AggregatingMergeTree or deduplication key in CollapsingMergeTree. It is used as the primary key if PRIMARY KEY is not provided.</li><li>PARTITION BY — The partitioning key. Optional. For example, if partitioning by month is desired: toYYYYMM(date_column), where date_column is of the Date data type. Partitions are named in the &quot;YYYYMM&quot; format.</li><li>PRIMARY KEY — Optional. Always the same or a prefix of the sorting key. In many cases, it is unnecessary to define the PRIMARY KEY; it defaults to ORDER BY. It is used to build the index itself (primary.idx).</li></ul></li>`,2),x=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"When do ORDER BY and PRIMARY KEY differ?"),e("p",null,"If, for instance, there is a need to add an additional column to an aggregation key, it might be recommended to only modify the ORDER BY (or sorting key) through an ALTER TABLE, keeping the PRIMARY KEY and, consequently, its index file, unchanged. This way, a complete reindexing can be avoided, as the old PK will be a prefix of the new sorting key, an acceptable situation for the engine's operation. Obviously, the strategy will depend on the cardinality and the intended use as a filter for the new column.")],-1),k={class:"hint-container tip"},R=e("p",{class:"hint-container-title"},"Sorting key vs Primary key",-1),T={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},I=t(`<h6 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  CREATE TABLE my_base_raw.transactions_raw(
    \`id_transaction\` Int64,
    \`user_id\` Int32,
    \`timestamp\` DateTime(3),
    \`type\` String,
    \`sequence\` string,
    \`amount\` Decimal(10,2),
    \`__ver\` Int64) ENGINE = MergeTree()
  ORDER BY (id_transaction)
  PARTITION BY toYYYYMM(timestamp)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="partitions-and-indexes" tabindex="-1"><a class="header-anchor" href="#partitions-and-indexes" aria-hidden="true">#</a> Partitions and Indexes</h6><ul><li>Additionally, we can list the different partitions/parts of each table in ClickHouse by querying the system.parts system table. <code>system.parts</code>.</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT
    partition,
    name,
    active
FROM system.parts
WHERE (table = &#39;transactions_raw&#39;) AND (partition = &#39;202310&#39;)

Query id: 6b6aa9ec-fc61-4217-bd47-a3c4fd9400b5

┌─partition─┬─name────────────────────────┬─active─┐
│ 202310    │ 202310_4475842_4490464_1414 │      1 │
│ 202310    │ 202310_4490465_4511646_1317 │      1 │
│ 202310    │ 202310_4511647_4515242_1330 │      1 │
│ 202310    │ 202310_4515243_4515584_174  │      0 │
│ 202310    │ 202310_4515243_4515585_175  │      0 │
│ 202310    │ 202310_4515243_4515593_183  │      0 │
│ 202310    │ 202310_4515243_4515594_184  │      0 │
│ 202310    │ 202310_4515243_4515595_185  │      1 │
│ 202310    │ 202310_4515595_4515595_0    │      0 │
│ 202310    │ 202310_4515596_4515596_0    │      1 │
│ 202310    │ 202310_4515597_4515597_0    │      1 │
│ 202310    │ 202310_4515598_4515598_0    │      1 │
│ 202310    │ 202310_4515599_4515599_0    │      1 │
└───────────┴─────────────────────────────┴────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Breakdown of the part name: 202310_4515243_4515595_185:</p><ul><li><code>202310</code> is the partition name.</li><li><code>4515243</code> is the minimum PK number of the data block.</li><li><code>4515595</code> is the maximum PK number of the data block.</li><li><code>185</code> is the mutation version (if a part has mutated).rte ha mutado).</li></ul>`,7),Y={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},M=t('<h6 id="how-do-sparse-indices-work" tabindex="-1"><a class="header-anchor" href="#how-do-sparse-indices-work" aria-hidden="true">#</a> How do sparse indices work?</h6><p>Given the following index within a partition of a table: <img src="'+o+'" alt="primarykeys.jpeg" loading="lazy"> If we use the following filters in the WHERE clause of a query, the initial pruning would be:</p><ul><li>CounterID in (&#39;a&#39;, &#39;h&#39;) → ranges of marks [0, 3) and [6, 8).</li><li>CounterID IN (&#39;a&#39;, &#39;h&#39;) AND Date = 3 → ranges of marks [2, 3) and [7, 8).</li><li>Date = 3 → range of marks [1, 10].</li></ul><h6 id="graphical-representation-of-index-and-storage-strategy" tabindex="-1"><a class="header-anchor" href="#graphical-representation-of-index-and-storage-strategy" aria-hidden="true">#</a> Graphical representation of index and storage strategy</h6><img src="'+d+'" style="background-color:white;"><img src="'+l+'" style="background-color:white;"><img src="'+c+'" style="background-color:white;"><h3 id="engine-kafka" tabindex="-1"><a class="header-anchor" href="#engine-kafka" aria-hidden="true">#</a> ENGINE Kafka</h3><p>Tables defined with ENGINE = Kafka act as event consumers in topics and do not serve as permanent storage.</p><h3 id="materializedviews" tabindex="-1"><a class="header-anchor" href="#materializedviews" aria-hidden="true">#</a> MaterializedViews</h3>',10),O={href:"https://den-crane.github.io/Everything_you_should_know_about_materialized_views_commented.pdf",target:"_blank",rel:"noopener noreferrer"};function A(N,L){const n=u("ExternalLinkIcon");return m(),p("div",null,[f,b,v(" more "),_,e("ol",null,[y,e("li",null,[i("Organizes data by the primary key ("),e("a",E,[i("sparse index"),a(n)]),i(").")]),w]),x,e("div",k,[R,e("p",null,[i("Sorting key defines order in which data will be stored on disk, while primary key defines how data will be structured for queries. Usually those are the same (and in this case you can omit PRIMARY KEY expression, Clickhouse will take that info from ORDER BY expression). "),e("a",T,[i("link"),a(n)])])]),I,e("p",null,[e("a",Y,[i("Reading"),a(n)])]),M,e("p",null,[i("In ClickHouse, MaterializedViews function as triggers for the source table of the query, meaning the database offers reactive functionality to new rows "),e("a",O,[i("Reading"),a(n)])])])}const B=h(g,[["render",A],["__file","1.html.vue"]]);export{B as default};
