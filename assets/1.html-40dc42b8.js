import{_ as r,a as s,b as d,c as l}from"./indexes-8669c5b8.js";import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as u,c as m,d as h,a as e,b as i,f as a,e as t}from"./app-32cde3ea.js";const v={},p=e("p",null,"ClickHouse is a high-performance, column-oriented SQL database management system (DBMS) for online analytical processing (OLAP). It is available as both an open-source software and a cloud offering.",-1),_=t('<h2 id="clickhouse" tabindex="-1"><a class="header-anchor" href="#clickhouse" aria-hidden="true">#</a> Clickhouse</h2><h3 id="column-oriented-vs-row-oriented" tabindex="-1"><a class="header-anchor" href="#column-oriented-vs-row-oriented" aria-hidden="true">#</a> Column-Oriented vs Row-Oriented</h3><ul><li>In a row-oriented database management system (DBMS), data is stored in rows, with all values related to a row stored physically next to each other. <img src="'+r+'" alt="row-oriented.gif" loading="lazy"></li><li>In a column-oriented DBMS, data is stored in columns, with values from the same columns stored together. <img src="'+s+'" alt="column-oriented.gif" loading="lazy"></li></ul><h3 id="engine-mergetree" tabindex="-1"><a class="header-anchor" href="#engine-mergetree" aria-hidden="true">#</a> ENGINE MergeTree</h3>',4),b=e("li",null,"It can be considered ClickHouse's default engine.",-1),f={href:"https://www2.cs.sfu.ca/CourseCentral/354/zaiane/material/notes/Chapter11/node5.html",target:"_blank",rel:"noopener noreferrer"},g=t(`<li>Data can be partitioned (partitions + parts).</li><li>Creation statement:<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr1] [COMMENT ...] [CODEC(codec1)] [TTL expr1] [PRIMARY KEY],
    name2 [type2] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr2] [COMMENT ...] [CODEC(codec2)] [TTL expr2] [PRIMARY KEY],
    ...
    INDEX index_name1 expr1 TYPE type1(...) [GRANULARITY value1],
    INDEX index_name2 expr2 TYPE type2(...) [GRANULARITY value2],
    ...
    PROJECTION projection_name_1 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY]),
    PROJECTION projection_name_2 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY])
) ENGINE = MergeTree()
ORDER BY expr
[PARTITION BY expr]
[PRIMARY KEY expr]
[SAMPLE BY expr]
[TTL expr
    [DELETE|TO DISK &#39;xxx&#39;|TO VOLUME &#39;xxx&#39; [, ...] ]
    [WHERE conditions]
    [GROUP BY key_expr [SET v1 = aggr_func(v1) [, v2 = aggr_func(v2) ...]] ] ]
[SETTINGS name=value, ...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ENGINE — The MergeTree() engine takes no parameters.</li><li>ORDER BY — The sorting key - ClickHouse uses the sorting key to determine how information is stored on disk. It also serves specific functions in MergeTree family engines, such as aggregation key in AggregatingMergeTree or deduplication key in CollapsingMergeTree. It is used as the primary key if PRIMARY KEY is not provided.</li><li>PARTITION BY — The partitioning key. Optional. For example, if partitioning by month is desired: toYYYYMM(date_column), where date_column is of the Date data type. Partitions are named in the &quot;YYYYMM&quot; format.</li><li>PRIMARY KEY — Optional. Always the same or a prefix of the sorting key. In many cases, it is unnecessary to define the PRIMARY KEY; it defaults to ORDER BY. It is used to build the index itself (primary.idx).</li></ul></li>`,2),E=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"When do ORDER BY and PRIMARY KEY differ?"),e("p",null,"If, for instance, there is a need to add an additional column to an aggregation key, it might be recommended to only modify the ORDER BY (or sorting key) through an ALTER TABLE, keeping the PRIMARY KEY and, consequently, its index file, unchanged. This way, a complete reindexing can be avoided, as the old PK will be a prefix of the new sorting key, an acceptable situation for the engine's operation. Obviously, the strategy will depend on the cardinality and the intended use as a filter for the new column.")],-1),x={class:"hint-container tip"},y=e("p",{class:"hint-container-title"},"Sorting key vs Primary key",-1),R={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},k=t(`<h6 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  CREATE TABLE my_base_raw.transactions_raw(
    \`id_transaction\` Int64,
    \`user_id\` Int32,
    \`timestamp\` DateTime(3),
    \`type\` String,
    \`sequence\` string,
    \`amount\` Decimal(10,2),
    \`__ver\` Int64) ENGINE = MergeTree()
  ORDER BY (id_transaction)
  PARTITION BY toYYYYMM(timestamp)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="partitions-and-indexes" tabindex="-1"><a class="header-anchor" href="#partitions-and-indexes" aria-hidden="true">#</a> Partitions and Indexes</h6><ul><li>Additionally, we can list the different partitions/parts of each table in ClickHouse by querying the system.parts system table. <code>system.parts</code>.</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT
    partition,
    name,
    active
FROM system.parts
WHERE (table = &#39;transactions_raw&#39;) AND (partition = &#39;202310&#39;)

Query id: 6b6aa9ec-fc61-4217-bd47-a3c4fd9400b5

┌─partition─┬─name────────────────────────┬─active─┐
│ 202310    │ 202310_4475842_4490464_1414 │      1 │
│ 202310    │ 202310_4490465_4511646_1317 │      1 │
│ 202310    │ 202310_4511647_4515242_1330 │      1 │
│ 202310    │ 202310_4515243_4515584_174  │      0 │
│ 202310    │ 202310_4515243_4515585_175  │      0 │
│ 202310    │ 202310_4515243_4515593_183  │      0 │
│ 202310    │ 202310_4515243_4515594_184  │      0 │
│ 202310    │ 202310_4515243_4515595_185  │      1 │
│ 202310    │ 202310_4515595_4515595_0    │      0 │
│ 202310    │ 202310_4515596_4515596_0    │      1 │
│ 202310    │ 202310_4515597_4515597_0    │      1 │
│ 202310    │ 202310_4515598_4515598_0    │      1 │
│ 202310    │ 202310_4515599_4515599_0    │      1 │
└───────────┴─────────────────────────────┴────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Breakdown of the part name: 202310_4515243_4515595_185:</p><ul><li><code>202310</code> is the partition name.</li><li><code>4515243</code> is the minimum PK number of the data block.</li><li><code>4515595</code> is the maximum PK number of the data block.</li><li><code>185</code> is the mutation version (if a part has mutated).rte ha mutado).</li></ul>`,7),w={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},T=t('<h6 id="how-do-sparse-indices-work" tabindex="-1"><a class="header-anchor" href="#how-do-sparse-indices-work" aria-hidden="true">#</a> How do sparse indices work?</h6><p>Given the following index within a partition of a table: <img src="'+d+'" alt="primarykeys.jpeg" loading="lazy"> If we use the following filters in the WHERE clause of a query, the initial pruning would be:</p><ul><li>CounterID in (&#39;a&#39;, &#39;h&#39;) → ranges of marks [0, 3) and [6, 8).</li><li>CounterID IN (&#39;a&#39;, &#39;h&#39;) AND Date = 3 → ranges of marks [2, 3) and [7, 8).</li><li>Date = 3 → range of marks [1, 10].</li></ul><h6 id="graphical-representation-of-index-pruning" tabindex="-1"><a class="header-anchor" href="#graphical-representation-of-index-pruning" aria-hidden="true">#</a> Graphical representation of index pruning</h6><figure><img src="'+l+'" alt="indexes.png" tabindex="0" loading="lazy"><figcaption>indexes.png</figcaption></figure><h3 id="engine-kafka" tabindex="-1"><a class="header-anchor" href="#engine-kafka" aria-hidden="true">#</a> ENGINE Kafka</h3><p>Tables defined with ENGINE = Kafka act as event consumers in topics and do not serve as permanent storage.</p><h3 id="materializedviews" tabindex="-1"><a class="header-anchor" href="#materializedviews" aria-hidden="true">#</a> MaterializedViews</h3>',8),I={href:"https://den-crane.github.io/Everything_you_should_know_about_materialized_views_commented.pdf",target:"_blank",rel:"noopener noreferrer"};function Y(O,A){const n=c("ExternalLinkIcon");return u(),m("div",null,[p,h(" more "),_,e("ol",null,[b,e("li",null,[i("Organizes data by the primary key ("),e("a",f,[i("sparse index"),a(n)]),i(").")]),g]),E,e("div",x,[y,e("p",null,[i("Sorting key defines order in which data will be stored on disk, while primary key defines how data will be structured for queries. Usually those are the same (and in this case you can omit PRIMARY KEY expression, Clickhouse will take that info from ORDER BY expression). "),e("a",R,[i("link"),a(n)])])]),k,e("p",null,[e("a",w,[i("Reading"),a(n)])]),T,e("p",null,[i("In ClickHouse, MaterializedViews function as triggers for the source table of the query, meaning the database offers reactive functionality to new rows "),e("a",I,[i("Reading"),a(n)])])])}const L=o(v,[["render",Y],["__file","1.html.vue"]]);export{L as default};
